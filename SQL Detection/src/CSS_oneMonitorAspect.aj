
import java.io.*;
import java.util.*;
import javamoprt.*;
import java.lang.ref.*;
import org.aspectj.lang.*;

class SafeArrayListRawMonitor_Set extends javamoprt.MOPSet {
	protected SafeArrayListRawMonitor[] elementData;

	public SafeArrayListRawMonitor_Set(){
		this.size = 0;
		this.elementData = new SafeArrayListRawMonitor[4];
	}

	public final int size(){
		while(size > 0 && elementData[size-1].MOP_terminated) {
			elementData[--size] = null;
		}
		return size;
	}

	public final boolean add(MOPMonitor e){
		ensureCapacity();
		elementData[size++] = (SafeArrayListRawMonitor)e;
		return true;
	}

	public final void endObject(int idnum){
		int numAlive = 0;
		for(int i = 0; i < size; i++){
			SafeArrayListRawMonitor monitor = elementData[i];
			if(!monitor.MOP_terminated){
				monitor.endObject(idnum);
			}
			if(!monitor.MOP_terminated){
				elementData[numAlive++] = monitor;
			}
		}
		for(int i = numAlive; i < size; i++){
			elementData[i] = null;
		}
		size = numAlive;
	}

	public final boolean alive(){
		for(int i = 0; i < size; i++){
			MOPMonitor monitor = elementData[i];
			if(!monitor.MOP_terminated){
				return true;
			}
		}
		return false;
	}

	public final void endObjectAndClean(int idnum){
		int size = this.size;
		this.size = 0;
		for(int i = size - 1; i >= 0; i--){
			MOPMonitor monitor = elementData[i];
			if(monitor != null && !monitor.MOP_terminated){
				monitor.endObject(idnum);
			}
			elementData[i] = null;
		}
		elementData = null;
	}

	public final void ensureCapacity() {
		int oldCapacity = elementData.length;
		if (size + 1 > oldCapacity) {
			cleanup();
		}
		if (size + 1 > oldCapacity) {
			SafeArrayListRawMonitor[] oldData = elementData;
			int newCapacity = (oldCapacity * 3) / 2 + 1;
			if (newCapacity < size + 1){
				newCapacity = size + 1;
			}
			elementData = Arrays.copyOf(oldData, newCapacity);
		}
	}

	public final void cleanup() {
		int numAlive = 0 ;
		for(int i = 0; i < size; i++){
			SafeArrayListRawMonitor monitor = (SafeArrayListRawMonitor)elementData[i];
			if(!monitor.MOP_terminated){
				elementData[numAlive] = monitor;
				numAlive++;
			}
		}
		for(int i = numAlive; i < size; i++){
			elementData[i] = null;
		}
		size = numAlive;
	}

	public final void event_add(ArrayList t, Object o) {
		int numAlive = 0 ;
		for(int i = 0; i < this.size; i++){
			SafeArrayListRawMonitor monitor = (SafeArrayListRawMonitor)this.elementData[i];
			if(!monitor.MOP_terminated){
				elementData[numAlive] = monitor;
				numAlive++;

				monitor.event_add(t, o);
			}
		}
		for(int i = numAlive; i < this.size; i++){
			this.elementData[i] = null;
		}
		size = numAlive;
	}

	public final void event_contains(ArrayList t, Object o) {
		int numAlive = 0 ;
		for(int i = 0; i < this.size; i++){
			SafeArrayListRawMonitor monitor = (SafeArrayListRawMonitor)this.elementData[i];
			if(!monitor.MOP_terminated){
				elementData[numAlive] = monitor;
				numAlive++;

				monitor.event_contains(t, o);
			}
		}
		for(int i = numAlive; i < this.size; i++){
			this.elementData[i] = null;
		}
		size = numAlive;
	}

	public final void event_remove(ArrayList t, Object o) {
		int numAlive = 0 ;
		for(int i = 0; i < this.size; i++){
			SafeArrayListRawMonitor monitor = (SafeArrayListRawMonitor)this.elementData[i];
			if(!monitor.MOP_terminated){
				elementData[numAlive] = monitor;
				numAlive++;

				monitor.event_remove(t, o);
			}
		}
		for(int i = numAlive; i < this.size; i++){
			this.elementData[i] = null;
		}
		size = numAlive;
	}
}

class SafeArrayListRawMonitor extends javamoprt.MOPMonitor implements Cloneable, javamoprt.MOPObject {
	public Object clone() {
		try {
			SafeArrayListRawMonitor ret = (SafeArrayListRawMonitor) super.clone();
			return ret;
		}
		catch (CloneNotSupportedException e) {
			throw new InternalError(e.toString());
		}
	}

	public final void event_add(ArrayList t, Object o) {
		MOP_lastevent = 0;
		{
			if (o.toString().contains("<\\script")) {
				System.err.println("Possibility of cross site scripting! Aborting");
				System.exit(1);
			}
		}
	}

	public final void event_contains(ArrayList t, Object o) {
		MOP_lastevent = 1;
	}

	public final void event_remove(ArrayList t, Object o) {
		MOP_lastevent = 2;
	}

	public final void reset() {
		MOP_lastevent = -1;
	}

	public javamoprt.ref.MOPWeakReference MOPRef_t;
	public javamoprt.ref.MOPWeakReference MOPRef_o;

	public final void endObject(int idnum){
		switch(idnum){
			case 0:
			break;
			case 1:
			break;
		}
		switch(MOP_lastevent) {
			case -1:
			return;
			case 0:
			//add
			return;
			case 1:
			//contains
			return;
			case 2:
			//remove
			return;
		}
		return;
	}

}

public aspect CSS_oneMonitorAspect implements javamoprt.MOPObject {
	javamoprt.map.MOPMapManager CSS_oneMapManager;
	public CSS_oneMonitorAspect(){
		CSS_oneMapManager = new javamoprt.map.MOPMapManager();
		CSS_oneMapManager.start();
	}

	// Declarations for the Lock
	static Object CSS_one_MOPLock = new Object();

	static boolean SafeArrayList_activated = false;

	// Declarations for Indexing Trees
	static javamoprt.map.MOPAbstractMap SafeArrayList_t_o_Map = new javamoprt.map.MOPMapOfMapSet(0);
	static javamoprt.ref.MOPWeakReference SafeArrayList_t_o_Map_cachekey_0 = javamoprt.map.MOPBasicRefMap.NULRef;
	static javamoprt.ref.MOPWeakReference SafeArrayList_t_o_Map_cachekey_1 = javamoprt.map.MOPBasicRefMap.NULRef;
	static SafeArrayListRawMonitor SafeArrayList_t_o_Map_cachenode = null;

	// Trees for References
	static javamoprt.map.MOPRefMap CSS_one_ArrayList_RefMap = new javamoprt.map.MOPBasicRefMap();
	static javamoprt.map.MOPRefMap CSS_one_Object_RefMap = new javamoprt.map.MOPBasicRefMap();

	pointcut MOP_CommonPointCut() : !within(javamoprt.MOPObject+) && !adviceexecution();
	pointcut SafeArrayList_add(ArrayList t, Object o) : (call(* Collection+.add(Object)) && target(t) && args(o)) && MOP_CommonPointCut();
	after (ArrayList t, Object o) : SafeArrayList_add(t, o) {
		SafeArrayList_activated = true;
		synchronized(CSS_one_MOPLock) {
			Object obj;
			javamoprt.map.MOPMap tempMap;
			SafeArrayListRawMonitor mainMonitor = null;
			javamoprt.map.MOPMap mainMap = null;
			javamoprt.ref.MOPWeakReference TempRef_t;
			javamoprt.ref.MOPWeakReference TempRef_o;

			// Cache Retrieval
			if (t == SafeArrayList_t_o_Map_cachekey_0.get() && o == SafeArrayList_t_o_Map_cachekey_1.get()) {
				TempRef_t = SafeArrayList_t_o_Map_cachekey_0;
				TempRef_o = SafeArrayList_t_o_Map_cachekey_1;

				mainMonitor = SafeArrayList_t_o_Map_cachenode;
			} else {
				TempRef_t = CSS_one_ArrayList_RefMap.getRef(t);
				TempRef_o = CSS_one_Object_RefMap.getRef(o);
			}

			if (mainMonitor == null) {
				tempMap = SafeArrayList_t_o_Map;
				obj = tempMap.getMap(TempRef_t);
				if (obj == null) {
					obj = new javamoprt.map.MOPMapOfMonitor(1);
					tempMap.putMap(TempRef_t, obj);
				}
				mainMap = (javamoprt.map.MOPAbstractMap)obj;
				mainMonitor = (SafeArrayListRawMonitor)mainMap.getNode(TempRef_o);

				if (mainMonitor == null) {
					mainMonitor = new SafeArrayListRawMonitor();

					mainMonitor.MOPRef_t = TempRef_t;
					mainMonitor.MOPRef_o = TempRef_o;

					mainMap.putNode(TempRef_o, mainMonitor);
				}

				SafeArrayList_t_o_Map_cachekey_0 = TempRef_t;
				SafeArrayList_t_o_Map_cachekey_1 = TempRef_o;
				SafeArrayList_t_o_Map_cachenode = mainMonitor;
			}

			mainMonitor.event_add(t, o);
		}
	}

	pointcut SafeArrayList_contains(ArrayList t, Object o) : (call(* Collection+.contains(Object)) && target(t) && args(o)) && MOP_CommonPointCut();
	before (ArrayList t, Object o) : SafeArrayList_contains(t, o) {
		SafeArrayList_activated = true;
		synchronized(CSS_one_MOPLock) {
			Object obj;
			javamoprt.map.MOPMap tempMap;
			SafeArrayListRawMonitor mainMonitor = null;
			javamoprt.map.MOPMap mainMap = null;
			javamoprt.ref.MOPWeakReference TempRef_t;
			javamoprt.ref.MOPWeakReference TempRef_o;

			// Cache Retrieval
			if (t == SafeArrayList_t_o_Map_cachekey_0.get() && o == SafeArrayList_t_o_Map_cachekey_1.get()) {
				TempRef_t = SafeArrayList_t_o_Map_cachekey_0;
				TempRef_o = SafeArrayList_t_o_Map_cachekey_1;

				mainMonitor = SafeArrayList_t_o_Map_cachenode;
			} else {
				TempRef_t = CSS_one_ArrayList_RefMap.getRef(t);
				TempRef_o = CSS_one_Object_RefMap.getRef(o);
			}

			if (mainMonitor == null) {
				tempMap = SafeArrayList_t_o_Map;
				obj = tempMap.getMap(TempRef_t);
				if (obj == null) {
					obj = new javamoprt.map.MOPMapOfMonitor(1);
					tempMap.putMap(TempRef_t, obj);
				}
				mainMap = (javamoprt.map.MOPAbstractMap)obj;
				mainMonitor = (SafeArrayListRawMonitor)mainMap.getNode(TempRef_o);

				if (mainMonitor == null) {
					mainMonitor = new SafeArrayListRawMonitor();

					mainMonitor.MOPRef_t = TempRef_t;
					mainMonitor.MOPRef_o = TempRef_o;

					mainMap.putNode(TempRef_o, mainMonitor);
				}

				SafeArrayList_t_o_Map_cachekey_0 = TempRef_t;
				SafeArrayList_t_o_Map_cachekey_1 = TempRef_o;
				SafeArrayList_t_o_Map_cachenode = mainMonitor;
			}

			mainMonitor.event_contains(t, o);
		}
	}

	pointcut SafeArrayList_remove(ArrayList t, Object o) : (call(* Collection+.remove(Object)) && target(t) && args(o)) && MOP_CommonPointCut();
	after (ArrayList t, Object o) : SafeArrayList_remove(t, o) {
		SafeArrayList_activated = true;
		synchronized(CSS_one_MOPLock) {
			Object obj;
			javamoprt.map.MOPMap tempMap;
			SafeArrayListRawMonitor mainMonitor = null;
			javamoprt.map.MOPMap mainMap = null;
			javamoprt.ref.MOPWeakReference TempRef_t;
			javamoprt.ref.MOPWeakReference TempRef_o;

			// Cache Retrieval
			if (t == SafeArrayList_t_o_Map_cachekey_0.get() && o == SafeArrayList_t_o_Map_cachekey_1.get()) {
				TempRef_t = SafeArrayList_t_o_Map_cachekey_0;
				TempRef_o = SafeArrayList_t_o_Map_cachekey_1;

				mainMonitor = SafeArrayList_t_o_Map_cachenode;
			} else {
				TempRef_t = CSS_one_ArrayList_RefMap.getRef(t);
				TempRef_o = CSS_one_Object_RefMap.getRef(o);
			}

			if (mainMonitor == null) {
				tempMap = SafeArrayList_t_o_Map;
				obj = tempMap.getMap(TempRef_t);
				if (obj == null) {
					obj = new javamoprt.map.MOPMapOfMonitor(1);
					tempMap.putMap(TempRef_t, obj);
				}
				mainMap = (javamoprt.map.MOPAbstractMap)obj;
				mainMonitor = (SafeArrayListRawMonitor)mainMap.getNode(TempRef_o);

				if (mainMonitor == null) {
					mainMonitor = new SafeArrayListRawMonitor();

					mainMonitor.MOPRef_t = TempRef_t;
					mainMonitor.MOPRef_o = TempRef_o;

					mainMap.putNode(TempRef_o, mainMonitor);
				}

				SafeArrayList_t_o_Map_cachekey_0 = TempRef_t;
				SafeArrayList_t_o_Map_cachekey_1 = TempRef_o;
				SafeArrayList_t_o_Map_cachenode = mainMonitor;
			}

			mainMonitor.event_remove(t, o);
		}
	}

}
